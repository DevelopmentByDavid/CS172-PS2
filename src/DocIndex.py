import argparse
import os
import sys
import time
import cProfile, pstats
import math
import re
import json
from operator import itemgetter, attrgetter, methodcaller

### GLOBALS
#inputs i.e. r 
STOP_FILE_PATH = "../stoplist.txt"
#outputs i.e. w
STATS_FILE_PATH = "../output/stats.txt"
POSTINDEX_FILE_PATH = "../output/posting-index.txt"
POSTINDEX_BACKUP_PATH = "../output/posting-index-backup.txt"
DOCUMENT_FILE_PATH = "../output/document-index.txt"
DOCUMENT_BACKUP_PATH = "../output/document-index-backup.txt"

#CLI
parser = argparse.ArgumentParser(description="Creates a posting index and document index from files specified")
parser.add_argument("-f", "--file", default = None,\
    help = "Specify file to add to the index.",\
    metavar="<filename>")
parser.add_argument("-d", "--dir", default = None,\
    help = "Specify directory to add to the index",\
    metavar="<directory>")
parser.add_argument("-s", "--stats", default = None,\
    help = "#print stats related to index creation.  #prints autogenerated file stats.txt",\
    action = "store_true")
parser.add_argument("-l", "--list", default = None, help = "#print list of files used for index.", action = "store_true")
parser.add_argument("--clear", default = None,\
    help = "Clear index and inverted index. If used with --file and other commands, clear will occur first then generate the new index. Generates backup files on use.",\
    action = "store_true")
parser.add_argument("--find", default = None, help = "Find term in inverted index")


#DocIndex class definition
class DocIndex:
    def __init__(self):
        # inits
        self.postingIndex = None
        self.docIndex = None
        self.stopSet = None
        self.fileList = None
        # loads
        self.loadAll()

    def loadAll(self):
        #print("Loading all necessary files...")
        self.loadStopList()
        self.loadPostingIndex()
        self.loadDocIndex()

    @staticmethod
    def strip(fileText):
        return re.sub(r"\W+|(\s\s+)|(\A\Z)+|(\\0)", ' ', fileText)

    @staticmethod
    def exists(toCheck):
        if os.path.exists(toCheck):
            return True
        #print("ERROR: \'", toCheck, "\' does not exist?")
        return False

    @staticmethod
    def notFound(name, path):
        pass
        # Error messages`
        # if not os.path.exists(path):
            #print("ERROR: Looked for \'", path, "\' and did not find it.")
        # if not os.paths.isfile(path):
            #print("ERROR:", name ," file path \'", path, "\' is not a file.")

    @staticmethod
    def countTokens(token, tokens):
        count = 0
        for tok  in tokens:
            if tok == token:
                count += 1
        return count
                
    def loadStopList(self):
        if os.path.exists(STOP_FILE_PATH) and os.path.isfile(STOP_FILE_PATH):
            f = open(STOP_FILE_PATH, 'r')
            self.stopSet = f.readlines()
            temp = set()
            for n in self.stopSet:

                temp.add(re.sub(r"\s+", "", self.strip(n)))
            f.close()
            self.stopSet = temp
            return
        self.notFound("Stop List", STOP_FILE_PATH)
        #print("WARNING: Currently using no stop list!")
    
    def loadPostingIndex(self):
        if os.path.exists(POSTINDEX_FILE_PATH) and os.path.isfile(POSTINDEX_FILE_PATH):
            f = open(POSTINDEX_FILE_PATH, 'r')
            try:
                self.postingIndex = json.load(f)
            except:
                self.postingIndex = {}
            f.close()
            return
        # In the case that the file does not exist    
        #print("Did not find an index file! Creating one from scratch..")
        os.makedirs(os.path.dirname(POSTINDEX_FILE_PATH), exist_ok = True)
        f = open(POSTINDEX_FILE_PATH, "w+")
        json.dump({}, f)
        f.close()
        self.postingIndex = dict()
        
    def loadDocIndex(self):
        if os.path.exists(DOCUMENT_FILE_PATH) and os.path.isfile(DOCUMENT_FILE_PATH):
            f = open(DOCUMENT_FILE_PATH, 'r')
            try:
                self.docIndex = json.load(f)
            except:
                self.docIndex = {}
            f.close()
            return
        # In the case that the file does not exist    
        #print("Did not find an inverted index file! Creating one from scratch..")
        os.makedirs(os.path.dirname(DOCUMENT_FILE_PATH), exist_ok = True)
        f = open(DOCUMENT_FILE_PATH, "w+")
        json.dump({}, f)
        f.close()
        self.docIndex = dict()
    
    def addDirectory(self, directory):
        # #print(directory)
        if(self.exists(directory)):
            for n in os.listdir(directory):
                if n.endswith(".txt"):
                    self.addDocument(directory + "/" + n)
        
    def addDocument(self, document):
        if not self.exists(document):
            return

        strippedText = []
        f = open(document, 'r')
        lines = f.readlines()
        for line in lines:
            strippedText.append(self.strip(line))
        f.close()
        stoppedTokens = self.tokenize(strippedText)
        docId = os.path.basename(document)
        self.addToDocIndex(docId, len(stoppedTokens))
        self.updatePostingIndex(stoppedTokens, docId)
        

    def removeStopWords(self, text):
        retText = []
        for n in text:
            if not n.lower() in self.stopSet:
                retText.append(n.lower())
        return retText

    def tokenize(self, strippedText):
        n = strippedText[0] #TODO: change this probably
        split = n.split(" ")
        stoppedTokens = self.removeStopWords(split)
        return stoppedTokens
    
    def addToDocIndex(self, docId, value):
        self.docIndex[docId] = {"_id": docId, "terms": value}
        
    def write(self): 
        self.writeAll()
    
    def writeAll(self):
        self.writeDocIndex()
        self.writePostingIndex()
        pass
    
    def writeDocIndex(self):
        #print("Writing to " + DOCUMENT_FILE_PATH)
        f = open(DOCUMENT_FILE_PATH, 'w')
        json.dump(self.docIndex, f)
        f.close()
    
    def writePostingIndex(self):
        #print("Writing to " + POSTINDEX_FILE_PATH)
        f = open(POSTINDEX_FILE_PATH, 'w')
        json.dump(self.postingIndex, f)
        f.close()

    def updatePostingIndex(self, tokens, docId):
        tokenSet = set(tokens)
        for token in tokenSet:
            count = self.countTokens(token, tokens)
            countDiff = 0
            if token in self.postingIndex:
                tCountOld = self.postingIndex[token]["tCount"]
                if docId in self.postingIndex[token]["postings"]:
                    docCountOld = self.postingIndex[token]["postings"][docId]["termFreq"]
                    countDiff = count - docCountOld
                else:
                    self.postingIndex[token]["postings"][docId] = dict()
                    self.postingIndex[token]["postings"][docId]["_id"] = docId
                    countDiff = count
                self.postingIndex[token]["postings"][docId]["termFreq"] = count
                tCountNew = countDiff + tCountOld
                self.postingIndex[token]["tCount"] = tCountNew
            else:
                self.postingIndex[token] = dict()
                self.postingIndex[token]["postings"] = dict()
                self.postingIndex[token]["postings"][docId] =  dict()
                self.postingIndex[token]["postings"][docId]["termFreq"] = count
                self.postingIndex[token]["postings"][docId]["_id"] = docId
                self.postingIndex[token]["tCount"] = count
    
    def clear(self):
        #print("Clearing and backing up files...")
        #save old file first then clear current ones
        #print("Backing up " + POSTINDEX_FILE_PATH + " to " + POSTINDEX_BACKUP_PATH)
        g = open(POSTINDEX_BACKUP_PATH, "w+")
        json.dump(self.postingIndex, g)
        g.close()

        #print("Clearing " + POSTINDEX_FILE_PATH)
        f = open(POSTINDEX_FILE_PATH, "w+")
        json.dump({}, f)
        f.close()

        #print("Backing up " + DOCUMENT_FILE_PATH + " to " + DOCUMENT_BACKUP_PATH)
        g = open(DOCUMENT_BACKUP_PATH, "w+")
        json.dump(self.docIndex, g)
        g.close()

        #print("Clearing " + DOCUMENT_FILE_PATH)
        f = open(DOCUMENT_FILE_PATH, "w+")
        json.dump({}, f)
        f.close()
    
    def findTerm(self, termToFind):
        if termToFind in self.postingIndex:
            return self.postingIndex[termToFind]
        return None
    
    def findDoc(self, docId):
        if docId in self.docIndex:
            return self.docIndex[docId]
        return None

    def getDocIndexSize(self):
        return len(self.docIndex)
                    

def main(args):
    args = parser.parse_args(args)
    index = DocIndex()
    if args.clear != None:
        index.clear()
    if args.file != None:
        index.addDocument(args.file)
        index.write()
    if args.dir != None:
        index.addDirectory(args.dir)
        index.write()
    if args.stats != None:
        #print("TODO")
        pass
    if args.list != None:
        #print("TODO")
        pass
    if args.find != None:
        termInfo = index.findTerm(args.find)
        if not termInfo == None:
            relevantDocs = dict()
            for n in termInfo["postings"]:
                relevantDocs[n] = index.findDoc(n)
            # print("Found!")
            return [termInfo, relevantDocs, index.getDocIndexSize()]
    return None


if __name__ == "__main__":
    main(sys.argv[1:])